import React, { Component } from "react";
import SimpleStorageContract from "./contracts/SimpleStorage.json";
import getWeb3 from "./utils/getWeb3";
import fs from "fs";
import truffleContract from "truffle-contract";

import readline from "readline";


import "./App.css";

var apiKey = "insert_your_api_key_here";
// If modifying these scopes, delete token.json.
const scopes = 'https://mail.google.com/';
// The file token.json stores the user's access and refresh tokens, and is
// created automatically when the authorization flow completes for the first
// time.


const clientId = 'get_your_own_client_id.apps.googleusercontent.com';
//these are generated by truffle and ok to publish
const emailToEth = { 'mr851837@gmail.com': '0x627306090abab3a6e1400e9345bc60c78a8bef57', 'rossimariors09@gmail.com': '0xf17f52151ebef6c7334fad080c5704d77216b732' };
const privateKeys = {
  '0x627306090abab3a6e1400e9345bc60c78a8bef57': '0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3',
  '0xf17f52151ebef6c7334fad080c5704d77216b732': '0xae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f'
}
var gapi = null;
var appObj = new Object();

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      value: 'Please write an essay about your favorite DOM element.'
    };

    this.handleChange = this.handleChange.bind(this);
    this.sendIt = this.sendEmail.bind(this);
  }

  state = { storageValue: 0, web3: null, accounts: null, contract: null, hide: true, from : "mr851837@gmail.com" };




  handleClientLoad() {
    window.gapi.client.setApiKey(apiKey);
    window.setTimeout(this.checkAuth, 1);
  };
  checkAuth() {
    window.gapi.auth2.authorize({
      client_id: clientId,
      scope: scopes,
      immediate: true
    },
      (authResult) => { appObj.handleAuthResult(authResult); }

    );
  };
  handleAuthClick() {
    window.gapi.auth2.authorize({
      client_id: clientId,
      scope: scopes,
      immediate: false
    },
      (authResult) => { appObj.handleAuthResult(authResult); }
    );
    return false;
  };
  handleAuthResult(authResult) {
    if (authResult && !authResult.error) {
      this.loadGmail();
    }
    else {
      this.handleAuthClick();
    }
  };
  loadGmail() {
    window.gapi.client.load('gmail', 'v1', () => { this.setState({ gapiReady: true }) });
  };



  loadGmailApi() {
    const script = document.createElement("script");
    script.src = "https://apis.google.com/js/client.js";

    script.onload = () => {
      window.gapi.load('client', () => {
        appObj = this;
        this.handleClientLoad()
      });
    };
    document.body.appendChild(script);
  };


  componentDidMount = async () => {

    try {
      this.loadGmailApi();
      // Get network provider and web3 instance.
      const web3 = await getWeb3();

      // Use web3 to get the user's accounts.
      const accounts = await web3.eth.getAccounts();



      // Get the contract instance.
      const Contract = truffleContract(SimpleStorageContract);
      Contract.setProvider(web3.currentProvider);
      const instance = await Contract.deployed();

      // Set web3, accounts, and contract to the state, and then proceed with an
      // example of interacting with the contract's methods.
      this.setState({ web3, accounts, contract: instance, from : "mr851837@gmail.com", to : "mr851837@gmail.com" }, this.runApplication);
    } catch (error) {
      // Catch any errors for any of the above operations.
      alert(
        `Failed to load web3, accounts, or contract. Check console for details.`
      );
      console.log(error);
    }
  };

  sendEmail = async (event) => {
    event.preventDefault();
    this.sign();
    // You can use UTF-8 encoding for the subject using the method below.
    // You can also just use a plain string if you don't need anything fancy.
    const utf8Subject = `=?utf-8?B?${Buffer.from(this.state.subject).toString('base64')}?=`;
    //var from = "mr851837@gmail.com";
    //var to = "mr851837@gmail.com";
    const messageParts = [
      'From: <' + 'mr851837@gmail.com' + '>',
      'To: <' + this.state.to + '>',
      'Content-Type: text/html; charset=utf-8',
      'MIME-Version: 1.0',
      `Subject: ${utf8Subject}`,
      '',
      this.state.message
    ];
    const message = messageParts.join('\n');

    // The body needs to be base64url encoded.
    const encodedMessage = Buffer.from(message)
      .toString('base64')
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=+$/, '');
    //creating the google api object with auth being the authetication client
    const gmail = window.gapi.client.gmail;
    var res = new Object();
    try {
      res = await gmail.users.messages.send({
        userId: 'me',
        resource: {
          raw: encodedMessage,
        },
      });
    } catch (error) {
      console.log(error);
    }

    console.log(res.data);

  }


  listEmails = async () => {
    if (window.gapi === undefined || window.gapi === null || window.gapi.client.gmail === undefined) {
      //this.loadYoutubeApi();
      return;
    }
    const gmail = window.gapi.client.gmail;
    var res = await gmail.users.messages.list({ userId: 'me' });
    //console.log(res.data);
    var emails_data = [];
    //for cycle over returned messages, each message has dictionary with id in it
    if(res.result.resultSizeEstimate == 0){
      emails = [];
      this.setState({ emails: emails });
      return;
    }
    for (var i = 0; i < res.result.messages.length; i++) {   //here we request for each message from the list of messages and get the message itself
      emails_data.push(await gmail.users.messages.get({ userId: 'me', id: res.result.messages[i]["id"] }));
    }
    var emails = [];
    emails_data.forEach(email => {
      var data = {};
      data["verified"] = undefined;
      data["date"] = email["headers"]["date"];
      for (var i = 0; i < email["result"]["payload"]["headers"].length; i++) {

        if (email["result"]["payload"]["headers"][i]["name"] === "From") {
          data["From"] = email["result"]["payload"]["headers"][i]["value"];
        }
        if (email["result"]["payload"]["headers"][i]["name"] === "To") {
          data["To"] = email["result"]["payload"]["headers"][i]["value"];
        }
        if (email["result"]["payload"]["headers"][i]["name"] === "Subject") {
          data["Subject"] = email["result"]["payload"]["headers"][i]["value"];
        }
      }
      data["message"] = email["result"]["snippet"];
      emails.push(data);

    });
    this.setState({ emails: emails });
  };

  handleChange(event) {
    const target = event.target;
    this.setState({ [target.name]: target.value });
  }
  sign = async () => {
    const { accounts, contract, web3 } = this.state;
    let addr = accounts[0];
    var signature = await web3.eth.accounts.sign(this.state.message, privateKeys[emailToEth[this.state.from]]);
    contract.saveHash(signature["signature"], { from: addr });    
    this.setState({ signAddr: addr, signature: signature["signature"], hide:false });
  };

  addFakeEmail = () =>{
    var emails = this.state.emails;
    emails[0]["message"] = emails[0]["message"] + " this is fake";
    this.setState({emails:emails})
  }

  fakeSender = () =>{
    var emails = this.state.emails;
    emails[0]["From"] = "<test@test.ch>";
    this.setState({emails:emails})
  }

  verify = async () => {
    const { web3, contract, emails } = this.state;
    var email = emails[0];
    var signature = await contract.hash_value();
    const origAddr = await web3.eth.accounts.recover(email["message"], signature);
    var verified = false;
    var email = emailToEth[email["From"].match(/<(.*?)>/)[1]] === undefined ? "" : emailToEth[email["From"].match(/<(.*?)>/)[1]].toLowerCase();
    if (origAddr.toLowerCase() === email) {
      this.state.emails[0]["verified"] = true;
      verified = true;
    }
    else{
      this.state.emails[0]["verified"] = false;
    }
    this.setState({lastVerification : verified})
  };

  runApplication = async () => {
    const { accounts, contract } = this.state;

    var hide = true;
    const hash = await contract.hash_value();

    // Update state with the result.
    this.setState({ hide:hide, hash: hash });
  };

  render() {
    if (this.state.signature !== undefined) {
      var sign = this.state.signature["messageHash"];
      var vals = this.state.signature;
    } else {
      var sign = "";
      var vals = {};
    }
    if (this.state.emails !== undefined) {

      var listItems = this.state.emails.map(function (d, idx) {

        return (<tr className={ d.verified === undefined ? null : d.verified ? "green" : "red" }><td>{d.From}</td><td>{d.Subject}</td><td>{d.message}</td><td>{d.verified ===undefined ? "undefined" : d.verified.toString()}</td></tr>);
      })
    }
    else {
      var listItems = [];
    }
    if (!this.state.web3) {
      return <div>Loading Web3, accounts, and contract...</div>;
    }
    return (
      <div className="App">
      <h1>Distrubuted signature DEMO</h1>
        <form onSubmit={this.sendIt} className="formBordered">
<table>
  <tbody>
          <tr>
            <td>
              From:
            </td>
            <td>
              <input type="text" name="from" value={this.state.from} onChange={this.handleChange} />
            </td>
          </tr>
          <tr>
            <td>
              To:
            </td>
            <td>
              <input type="text" name="to" value={this.state.to} onChange={this.handleChange} />
            </td>
          </tr>
          <tr>
            <td>
              Subject:
            </td>
            <td>
              <input type="text" name="subject" value={this.state.subject} onChange={this.handleChange} />
            </td>
          </tr>
          <tr>
            <td>
              Message:
              </td>
            <td>
              <input type="text" name="message" value={this.state.message} onChange={this.handleChange} />
            </td>
          </tr>  
          <tr>
            <td colSpan='2' ><input type="submit" value="Submit" /></td>
          </tr>
          </tbody>
          </table>
        
        </form>
      <div className={ this.state.hide ? "hidden" : "" }>
        <div>Message signed with signature: {this.state.signature}</div>
      </div>
      <div className="buttons">
      <button onClick={() => { this.listEmails() }}>ListEmails</button>
      <button onClick={() => { this.verify() }}>Verify Last message</button>
      
      <button onClick={() => { this.addFakeEmail() }}>Fake email</button>
      <button onClick={() => { this.fakeSender() }}>Fake sender</button>
      </div>
      <div className="bordered">
        <table><tbody><tr><th>From</th><th>Subject</th><th>Text</th><th>Verified</th></tr>
          {listItems}
        </tbody>
        </table>
      </div>
      </div >

    );
  }
}

export default App;
